import{extend as e,isArray as t,isMap as r,isIntegerKey as s,makeMap as n,isSymbol as o,hasOwn as c,isObject as i,hasChanged as a,capitalize as f,toRawType as u,def as l,isFunction as h,NOOP as d}from"@vue/shared";function warn(e,...t){console.warn(`[Vue warn] ${e}`,...t)}let p;class EffectScope{constructor(e=false){this.detached=e;this.active=true;this.effects=[];this.cleanups=[];this.parent=p;!e&&p&&(this.index=(p.scopes||(p.scopes=[])).push(this)-1)}run(e){if(this.active){const t=p;try{p=this;return e()}finally{p=t}}else"production"!==process.env.NODE_ENV&&warn("cannot run an inactive effect scope.")}on(){p=this}off(){p=this.parent}stop(e){if(this.active){let t,r;for(t=0,r=this.effects.length;t<r;t++)this.effects[t].stop();for(t=0,r=this.cleanups.length;t<r;t++)this.cleanups[t]();if(this.scopes)for(t=0,r=this.scopes.length;t<r;t++)this.scopes[t].stop(true);if(!this.detached&&this.parent&&!e){const e=this.parent.scopes.pop();if(e&&e!==this){this.parent.scopes[this.index]=e;e.index=this.index}}this.parent=void 0;this.active=false}}}function effectScope(e){return new EffectScope(e)}function recordEffectScope(e,t=p){t&&t.active&&t.effects.push(e)}function getCurrentScope(){return p}function onScopeDispose(e){p?p.cleanups.push(e):"production"!==process.env.NODE_ENV&&warn("onScopeDispose() is called when there is no active effect scope to be associated with.")}const createDep=e=>{const t=new Set(e);t.w=0;t.n=0;return t};const wasTracked=e=>(e.w&v)>0;const newTracked=e=>(e.n&v)>0;const initDepMarkers=({deps:e})=>{if(e.length)for(let t=0;t<e.length;t++)e[t].w|=v};const finalizeDepMarkers=e=>{const{deps:t}=e;if(t.length){let r=0;for(let s=0;s<t.length;s++){const n=t[s];wasTracked(n)&&!newTracked(n)?n.delete(e):t[r++]=n;n.w&=~v;n.n&=~v}t.length=r}};const g=new WeakMap;let _=0;let v=1;const R=30;let w;const y=Symbol("production"!==process.env.NODE_ENV?"iterate":"");const E=Symbol("production"!==process.env.NODE_ENV?"Map key iterate":"");class ReactiveEffect{constructor(e,t=null,r){this.fn=e;this.scheduler=t;this.active=true;this.deps=[];this.parent=void 0;recordEffectScope(this,r)}run(){if(!this.active)return this.fn();let e=w;let t=k;while(e){if(e===this)return;e=e.parent}try{this.parent=w;w=this;k=true;v=1<<++_;_<=R?initDepMarkers(this):cleanupEffect(this);return this.fn()}finally{_<=R&&finalizeDepMarkers(this);v=1<<--_;w=this.parent;k=t;this.parent=void 0;this.deferStop&&this.stop()}}stop(){if(w===this)this.deferStop=true;else if(this.active){cleanupEffect(this);this.onStop&&this.onStop();this.active=false}}}function cleanupEffect(e){const{deps:t}=e;if(t.length){for(let r=0;r<t.length;r++)t[r].delete(e);t.length=0}}function effect(t,r){t.effect&&(t=t.effect.fn);const s=new ReactiveEffect(t);if(r){e(s,r);r.scope&&recordEffectScope(s,r.scope)}r&&r.lazy||s.run();const n=s.run.bind(s);n.effect=s;return n}function stop(e){e.effect.stop()}let k=true;const m=[];function pauseTracking(){m.push(k);k=false}function enableTracking(){m.push(k);k=true}function resetTracking(){const e=m.pop();k=void 0===e||e}function track(e,t,r){if(k&&w){let s=g.get(e);s||g.set(e,s=new Map);let n=s.get(r);n||s.set(r,n=createDep());const o="production"!==process.env.NODE_ENV?{effect:w,target:e,type:t,key:r}:void 0;trackEffects(n,o)}}function trackEffects(e,t){let r=false;if(_<=R){if(!newTracked(e)){e.n|=v;r=!wasTracked(e)}}else r=!e.has(w);if(r){e.add(w);w.deps.push(e);"production"!==process.env.NODE_ENV&&w.onTrack&&w.onTrack(Object.assign({effect:w},t))}}function trigger(e,n,o,c,i,a){const f=g.get(e);if(!f)return;let u=[];if("clear"===n)u=[...f.values()];else if("length"===o&&t(e))f.forEach(((e,t)=>{("length"===t||t>=c)&&u.push(e)}));else{void 0!==o&&u.push(f.get(o));switch(n){case"add":if(t(e))s(o)&&u.push(f.get("length"));else{u.push(f.get(y));r(e)&&u.push(f.get(E))}break;case"delete":if(!t(e)){u.push(f.get(y));r(e)&&u.push(f.get(E))}break;case"set":r(e)&&u.push(f.get(y));break}}const l="production"!==process.env.NODE_ENV?{target:e,type:n,key:o,newValue:c,oldValue:i,oldTarget:a}:void 0;if(1===u.length)u[0]&&("production"!==process.env.NODE_ENV?triggerEffects(u[0],l):triggerEffects(u[0]));else{const e=[];for(const t of u)t&&e.push(...t);"production"!==process.env.NODE_ENV?triggerEffects(createDep(e),l):triggerEffects(createDep(e))}}function triggerEffects(e,r){const s=t(e)?e:[...e];for(const e of s)e.computed&&triggerEffect(e,r);for(const e of s)e.computed||triggerEffect(e,r)}function triggerEffect(t,r){if(t!==w||t.allowRecurse){"production"!==process.env.NODE_ENV&&t.onTrigger&&t.onTrigger(e({effect:t},r));t.scheduler?t.scheduler():t.run()}}const N=n("__proto__,__v_isRef,__isVue");const b=new Set(Object.getOwnPropertyNames(Symbol).filter((e=>"arguments"!==e&&"caller"!==e)).map((e=>Symbol[e])).filter(o));const S=createGetter();const V=createGetter(false,true);const O=createGetter(true);const D=createGetter(true,true);const I=createArrayInstrumentations();function createArrayInstrumentations(){const e={};["includes","indexOf","lastIndexOf"].forEach((t=>{e[t]=function(...e){const r=toRaw(this);for(let e=0,t=this.length;e<t;e++)track(r,"get",e+"");const s=r[t](...e);return-1===s||false===s?r[t](...e.map(toRaw)):s}}));["push","pop","shift","unshift","splice"].forEach((t=>{e[t]=function(...e){pauseTracking();const r=toRaw(this)[t].apply(this,e);resetTracking();return r}}));return e}function createGetter(e=false,r=false){return function get(n,a,f){if("__v_isReactive"===a)return!e;if("__v_isReadonly"===a)return e;if("__v_isShallow"===a)return r;if("__v_raw"===a&&f===(e?r?L:J:r?H:B).get(n))return n;const u=t(n);if(!e&&u&&c(I,a))return Reflect.get(I,a,f);const l=Reflect.get(n,a,f);if(o(a)?b.has(a):N(a))return l;e||track(n,"get",a);return r?l:isRef(l)?u&&s(a)?l:l.value:i(l)?e?readonly(l):reactive(l):l}}const M=createSetter();const T=createSetter(true);function createSetter(e=false){return function set(r,n,o,i){let f=r[n];if(isReadonly(f)&&isRef(f)&&!isRef(o))return false;if(!e){if(!isShallow(o)&&!isReadonly(o)){f=toRaw(f);o=toRaw(o)}if(!t(r)&&isRef(f)&&!isRef(o)){f.value=o;return true}}const u=t(r)&&s(n)?Number(n)<r.length:c(r,n);const l=Reflect.set(r,n,o,i);r===toRaw(i)&&(u?a(o,f)&&trigger(r,"set",n,o,f):trigger(r,"add",n,o));return l}}function deleteProperty(e,t){const r=c(e,t);const s=e[t];const n=Reflect.deleteProperty(e,t);n&&r&&trigger(e,"delete",t,void 0,s);return n}function has(e,t){const r=Reflect.has(e,t);o(t)&&b.has(t)||track(e,"has",t);return r}function ownKeys(e){track(e,"iterate",t(e)?"length":y);return Reflect.ownKeys(e)}const $={get:S,set:M,deleteProperty:deleteProperty,has:has,ownKeys:ownKeys};const x={get:O,set(e,t){"production"!==process.env.NODE_ENV&&warn(`Set operation on key "${String(t)}" failed: target is readonly.`,e);return true},deleteProperty(e,t){"production"!==process.env.NODE_ENV&&warn(`Delete operation on key "${String(t)}" failed: target is readonly.`,e);return true}};const j=e({},$,{get:V,set:T});const P=e({},x,{get:D});const toShallow=e=>e;const getProto=e=>Reflect.getPrototypeOf(e);function get$1(e,t,r=false,s=false){e=e.__v_raw;const n=toRaw(e);const o=toRaw(t);if(!r){t!==o&&track(n,"get",t);track(n,"get",o)}const{has:c}=getProto(n);const i=s?toShallow:r?toReadonly:toReactive;if(c.call(n,t))return i(e.get(t));if(c.call(n,o))return i(e.get(o));e!==n&&e.get(t)}function has$1(e,t=false){const r=this.__v_raw;const s=toRaw(r);const n=toRaw(e);if(!t){e!==n&&track(s,"has",e);track(s,"has",n)}return e===n?r.has(e):r.has(e)||r.has(n)}function size(e,t=false){e=e.__v_raw;!t&&track(toRaw(e),"iterate",y);return Reflect.get(e,"size",e)}function add(e){e=toRaw(e);const t=toRaw(this);const r=getProto(t);const s=r.has.call(t,e);if(!s){t.add(e);trigger(t,"add",e,e)}return this}function set$1(e,t){t=toRaw(t);const r=toRaw(this);const{has:s,get:n}=getProto(r);let o=s.call(r,e);if(o)"production"!==process.env.NODE_ENV&&checkIdentityKeys(r,s,e);else{e=toRaw(e);o=s.call(r,e)}const c=n.call(r,e);r.set(e,t);o?a(t,c)&&trigger(r,"set",e,t,c):trigger(r,"add",e,t);return this}function deleteEntry(e){const t=toRaw(this);const{has:r,get:s}=getProto(t);let n=r.call(t,e);if(n)"production"!==process.env.NODE_ENV&&checkIdentityKeys(t,r,e);else{e=toRaw(e);n=r.call(t,e)}const o=s?s.call(t,e):void 0;const c=t.delete(e);n&&trigger(t,"delete",e,void 0,o);return c}function clear(){const e=toRaw(this);const t=0!==e.size;const s="production"!==process.env.NODE_ENV?r(e)?new Map(e):new Set(e):void 0;const n=e.clear();t&&trigger(e,"clear",void 0,void 0,s);return n}function createForEach(e,t){return function forEach(r,s){const n=this;const o=n.__v_raw;const c=toRaw(o);const i=t?toShallow:e?toReadonly:toReactive;!e&&track(c,"iterate",y);return o.forEach(((e,t)=>r.call(s,i(e),i(t),n)))}}function createIterableMethod(e,t,s){return function(...n){const o=this.__v_raw;const c=toRaw(o);const i=r(c);const a="entries"===e||e===Symbol.iterator&&i;const f="keys"===e&&i;const u=o[e](...n);const l=s?toShallow:t?toReadonly:toReactive;!t&&track(c,"iterate",f?E:y);return{next(){const{value:e,done:t}=u.next();return t?{value:e,done:t}:{value:a?[l(e[0]),l(e[1])]:l(e),done:t}},[Symbol.iterator](){return this}}}}function createReadonlyMethod(e){return function(...t){if("production"!==process.env.NODE_ENV){const r=t[0]?`on key "${t[0]}" `:"";console.warn(`${f(e)} operation ${r}failed: target is readonly.`,toRaw(this))}return"delete"!==e&&this}}function createInstrumentations(){const e={get(e){return get$1(this,e)},get size(){return size(this)},has:has$1,add:add,set:set$1,delete:deleteEntry,clear:clear,forEach:createForEach(false,false)};const t={get(e){return get$1(this,e,false,true)},get size(){return size(this)},has:has$1,add:add,set:set$1,delete:deleteEntry,clear:clear,forEach:createForEach(false,true)};const r={get(e){return get$1(this,e,true)},get size(){return size(this,true)},has(e){return has$1.call(this,e,true)},add:createReadonlyMethod("add"),set:createReadonlyMethod("set"),delete:createReadonlyMethod("delete"),clear:createReadonlyMethod("clear"),forEach:createForEach(true,false)};const s={get(e){return get$1(this,e,true,true)},get size(){return size(this,true)},has(e){return has$1.call(this,e,true)},add:createReadonlyMethod("add"),set:createReadonlyMethod("set"),delete:createReadonlyMethod("delete"),clear:createReadonlyMethod("clear"),forEach:createForEach(true,true)};const n=["keys","values","entries",Symbol.iterator];n.forEach((n=>{e[n]=createIterableMethod(n,false,false);r[n]=createIterableMethod(n,true,false);t[n]=createIterableMethod(n,false,true);s[n]=createIterableMethod(n,true,true)}));return[e,r,t,s]}const[z,C,G,W]=createInstrumentations();function createInstrumentationGetter(e,t){const r=t?e?W:G:e?C:z;return(t,s,n)=>"__v_isReactive"===s?!e:"__v_isReadonly"===s?e:"__v_raw"===s?t:Reflect.get(c(r,s)&&s in t?r:t,s,n)}const K={get:createInstrumentationGetter(false,false)};const A={get:createInstrumentationGetter(false,true)};const F={get:createInstrumentationGetter(true,false)};const q={get:createInstrumentationGetter(true,true)};function checkIdentityKeys(e,t,r){const s=toRaw(r);if(s!==r&&t.call(e,s)){const t=u(e);console.warn(`Reactive ${t} contains both the raw and reactive versions of the same object${"Map"===t?" as keys":""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`)}}const B=new WeakMap;const H=new WeakMap;const J=new WeakMap;const L=new WeakMap;function targetTypeMap(e){switch(e){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function getTargetType(e){return e.__v_skip||!Object.isExtensible(e)?0:targetTypeMap(u(e))}function reactive(e){return isReadonly(e)?e:createReactiveObject(e,false,$,K,B)}function shallowReactive(e){return createReactiveObject(e,false,j,A,H)}function readonly(e){return createReactiveObject(e,true,x,F,J)}function shallowReadonly(e){return createReactiveObject(e,true,P,q,L)}function createReactiveObject(e,t,r,s,n){if(!i(e)){"production"!==process.env.NODE_ENV&&console.warn(`value cannot be made reactive: ${String(e)}`);return e}if(e.__v_raw&&!(t&&e.__v_isReactive))return e;const o=n.get(e);if(o)return o;const c=getTargetType(e);if(0===c)return e;const a=new Proxy(e,2===c?s:r);n.set(e,a);return a}function isReactive(e){return isReadonly(e)?isReactive(e.__v_raw):!!(e&&e.__v_isReactive)}function isReadonly(e){return!!(e&&e.__v_isReadonly)}function isShallow(e){return!!(e&&e.__v_isShallow)}function isProxy(e){return isReactive(e)||isReadonly(e)}function toRaw(e){const t=e&&e.__v_raw;return t?toRaw(t):e}function markRaw(e){l(e,"__v_skip",true);return e}const toReactive=e=>i(e)?reactive(e):e;const toReadonly=e=>i(e)?readonly(e):e;function trackRefValue(e){if(k&&w){e=toRaw(e);"production"!==process.env.NODE_ENV?trackEffects(e.dep||(e.dep=createDep()),{target:e,type:"get",key:"value"}):trackEffects(e.dep||(e.dep=createDep()))}}function triggerRefValue(e,t){e=toRaw(e);e.dep&&("production"!==process.env.NODE_ENV?triggerEffects(e.dep,{target:e,type:"set",key:"value",newValue:t}):triggerEffects(e.dep))}function isRef(e){return!!(e&&true===e.__v_isRef)}function ref(e){return createRef(e,false)}function shallowRef(e){return createRef(e,true)}function createRef(e,t){return isRef(e)?e:new RefImpl(e,t)}class RefImpl{constructor(e,t){this.__v_isShallow=t;this.dep=void 0;this.__v_isRef=true;this._rawValue=t?e:toRaw(e);this._value=t?e:toReactive(e)}get value(){trackRefValue(this);return this._value}set value(e){const t=this.__v_isShallow||isShallow(e)||isReadonly(e);e=t?e:toRaw(e);if(a(e,this._rawValue)){this._rawValue=e;this._value=t?e:toReactive(e);triggerRefValue(this,e)}}}function triggerRef(e){triggerRefValue(e,"production"!==process.env.NODE_ENV?e.value:void 0)}function unref(e){return isRef(e)?e.value:e}const Q={get:(e,t,r)=>unref(Reflect.get(e,t,r)),set:(e,t,r,s)=>{const n=e[t];if(isRef(n)&&!isRef(r)){n.value=r;return true}return Reflect.set(e,t,r,s)}};function proxyRefs(e){return isReactive(e)?e:new Proxy(e,Q)}class CustomRefImpl{constructor(e){this.dep=void 0;this.__v_isRef=true;const{get:t,set:r}=e((()=>trackRefValue(this)),(()=>triggerRefValue(this)));this._get=t;this._set=r}get value(){return this._get()}set value(e){this._set(e)}}function customRef(e){return new CustomRefImpl(e)}function toRefs(e){"production"===process.env.NODE_ENV||isProxy(e)||console.warn("toRefs() expects a reactive object but received a plain one.");const r=t(e)?new Array(e.length):{};for(const t in e)r[t]=toRef(e,t);return r}class ObjectRefImpl{constructor(e,t,r){this._object=e;this._key=t;this._defaultValue=r;this.__v_isRef=true}get value(){const e=this._object[this._key];return void 0===e?this._defaultValue:e}set value(e){this._object[this._key]=e}}function toRef(e,t,r){const s=e[t];return isRef(s)?s:new ObjectRefImpl(e,t,r)}var U;class ComputedRefImpl{constructor(e,t,r,s){this._setter=t;this.dep=void 0;this.__v_isRef=true;this[U]=false;this._dirty=true;this.effect=new ReactiveEffect(e,(()=>{if(!this._dirty){this._dirty=true;triggerRefValue(this)}}));this.effect.computed=this;this.effect.active=this._cacheable=!s;this.__v_isReadonly=r}get value(){const e=toRaw(this);trackRefValue(e);if(e._dirty||!e._cacheable){e._dirty=false;e._value=e.effect.run()}return e._value}set value(e){this._setter(e)}}U="__v_isReadonly";function computed(e,t,r=false){let s;let n;const o=h(e);if(o){s=e;n="production"!==process.env.NODE_ENV?()=>{console.warn("Write operation failed: computed value is readonly")}:d}else{s=e.get;n=e.set}const c=new ComputedRefImpl(s,n,o||!n,r);if("production"!==process.env.NODE_ENV&&t&&!r){c.effect.onTrack=t.onTrack;c.effect.onTrigger=t.onTrigger}return c}var X;const Y=Promise.resolve();const Z=[];let ee=false;const scheduler=e=>{Z.push(e);if(!ee){ee=true;Y.then(flush)}};const flush=()=>{for(let e=0;e<Z.length;e++)Z[e]();Z.length=0;ee=false};class DeferredComputedRefImpl{constructor(e){this.dep=void 0;this._dirty=true;this.__v_isRef=true;this[X]=true;let t;let r=false;let s=false;this.effect=new ReactiveEffect(e,(e=>{if(this.dep){if(e){t=this._value;r=true}else if(!s){const e=r?t:this._value;s=true;r=false;scheduler((()=>{this.effect.active&&this._get()!==e&&triggerRefValue(this);s=false}))}for(const e of this.dep)e.computed instanceof DeferredComputedRefImpl&&e.scheduler(true)}this._dirty=true}));this.effect.computed=this}_get(){if(this._dirty){this._dirty=false;return this._value=this.effect.run()}return this._value}get value(){trackRefValue(this);return toRaw(this)._get()}}X="__v_isReadonly";function deferredComputed(e){return new DeferredComputedRefImpl(e)}export{EffectScope,y as ITERATE_KEY,ReactiveEffect,computed,customRef,deferredComputed,effect,effectScope,enableTracking,getCurrentScope,isProxy,isReactive,isReadonly,isRef,isShallow,markRaw,onScopeDispose,pauseTracking,proxyRefs,reactive,readonly,ref,resetTracking,shallowReactive,shallowReadonly,shallowRef,stop,toRaw,toRef,toRefs,track,trigger,triggerRef,unref};

