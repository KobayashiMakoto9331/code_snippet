import{extend as e,isArray as t,toNumber as r,isMap as s,isIntegerKey as n,makeMap as o,isSymbol as c,hasOwn as i,isObject as a,hasChanged as f,capitalize as u,toRawType as l,def as h,isFunction as d,NOOP as p}from"@vue/shared";function warn(e,...t){console.warn(`[Vue warn] ${e}`,...t)}let g;class EffectScope{constructor(e=false){this.detached=e;this.active=true;this.effects=[];this.cleanups=[];this.parent=g;!e&&g&&(this.index=(g.scopes||(g.scopes=[])).push(this)-1)}run(e){if(this.active){const t=g;try{g=this;return e()}finally{g=t}}else"production"!==process.env.NODE_ENV&&warn("cannot run an inactive effect scope.")}on(){g=this}off(){g=this.parent}stop(e){if(this.active){let t,r;for(t=0,r=this.effects.length;t<r;t++)this.effects[t].stop();for(t=0,r=this.cleanups.length;t<r;t++)this.cleanups[t]();if(this.scopes)for(t=0,r=this.scopes.length;t<r;t++)this.scopes[t].stop(true);if(!this.detached&&this.parent&&!e){const e=this.parent.scopes.pop();if(e&&e!==this){this.parent.scopes[this.index]=e;e.index=this.index}}this.parent=void 0;this.active=false}}}function effectScope(e){return new EffectScope(e)}function recordEffectScope(e,t=g){t&&t.active&&t.effects.push(e)}function getCurrentScope(){return g}function onScopeDispose(e){g?g.cleanups.push(e):"production"!==process.env.NODE_ENV&&warn("onScopeDispose() is called when there is no active effect scope to be associated with.")}const createDep=e=>{const t=new Set(e);t.w=0;t.n=0;return t};const wasTracked=e=>(e.w&R)>0;const newTracked=e=>(e.n&R)>0;const initDepMarkers=({deps:e})=>{if(e.length)for(let t=0;t<e.length;t++)e[t].w|=R};const finalizeDepMarkers=e=>{const{deps:t}=e;if(t.length){let r=0;for(let s=0;s<t.length;s++){const n=t[s];wasTracked(n)&&!newTracked(n)?n.delete(e):t[r++]=n;n.w&=~R;n.n&=~R}t.length=r}};const _=new WeakMap;let v=0;let R=1;const w=30;let y;const E=Symbol("production"!==process.env.NODE_ENV?"iterate":"");const k=Symbol("production"!==process.env.NODE_ENV?"Map key iterate":"");class ReactiveEffect{constructor(e,t=null,r){this.fn=e;this.scheduler=t;this.active=true;this.deps=[];this.parent=void 0;recordEffectScope(this,r)}run(){if(!this.active)return this.fn();let e=y;let t=m;while(e){if(e===this)return;e=e.parent}try{this.parent=y;y=this;m=true;R=1<<++v;v<=w?initDepMarkers(this):cleanupEffect(this);return this.fn()}finally{v<=w&&finalizeDepMarkers(this);R=1<<--v;y=this.parent;m=t;this.parent=void 0;this.deferStop&&this.stop()}}stop(){if(y===this)this.deferStop=true;else if(this.active){cleanupEffect(this);this.onStop&&this.onStop();this.active=false}}}function cleanupEffect(e){const{deps:t}=e;if(t.length){for(let r=0;r<t.length;r++)t[r].delete(e);t.length=0}}function effect(t,r){t.effect&&(t=t.effect.fn);const s=new ReactiveEffect(t);if(r){e(s,r);r.scope&&recordEffectScope(s,r.scope)}r&&r.lazy||s.run();const n=s.run.bind(s);n.effect=s;return n}function stop(e){e.effect.stop()}let m=true;const N=[];function pauseTracking(){N.push(m);m=false}function enableTracking(){N.push(m);m=true}function resetTracking(){const e=N.pop();m=void 0===e||e}function track(e,t,r){if(m&&y){let s=_.get(e);s||_.set(e,s=new Map);let n=s.get(r);n||s.set(r,n=createDep());const o="production"!==process.env.NODE_ENV?{effect:y,target:e,type:t,key:r}:void 0;trackEffects(n,o)}}function trackEffects(e,t){let r=false;if(v<=w){if(!newTracked(e)){e.n|=R;r=!wasTracked(e)}}else r=!e.has(y);if(r){e.add(y);y.deps.push(e);"production"!==process.env.NODE_ENV&&y.onTrack&&y.onTrack(Object.assign({effect:y},t))}}function trigger(e,o,c,i,a,f){const u=_.get(e);if(!u)return;let l=[];if("clear"===o)l=[...u.values()];else if("length"===c&&t(e)){const e=r(i);u.forEach(((t,r)=>{("length"===r||r>=e)&&l.push(t)}))}else{void 0!==c&&l.push(u.get(c));switch(o){case"add":if(t(e))n(c)&&l.push(u.get("length"));else{l.push(u.get(E));s(e)&&l.push(u.get(k))}break;case"delete":if(!t(e)){l.push(u.get(E));s(e)&&l.push(u.get(k))}break;case"set":s(e)&&l.push(u.get(E));break}}const h="production"!==process.env.NODE_ENV?{target:e,type:o,key:c,newValue:i,oldValue:a,oldTarget:f}:void 0;if(1===l.length)l[0]&&("production"!==process.env.NODE_ENV?triggerEffects(l[0],h):triggerEffects(l[0]));else{const e=[];for(const t of l)t&&e.push(...t);"production"!==process.env.NODE_ENV?triggerEffects(createDep(e),h):triggerEffects(createDep(e))}}function triggerEffects(e,r){const s=t(e)?e:[...e];for(const e of s)e.computed&&triggerEffect(e,r);for(const e of s)e.computed||triggerEffect(e,r)}function triggerEffect(t,r){if(t!==y||t.allowRecurse){"production"!==process.env.NODE_ENV&&t.onTrigger&&t.onTrigger(e({effect:t},r));t.scheduler?t.scheduler():t.run()}}const b=o("__proto__,__v_isRef,__isVue");const S=new Set(Object.getOwnPropertyNames(Symbol).filter((e=>"arguments"!==e&&"caller"!==e)).map((e=>Symbol[e])).filter(c));const V=createGetter();const O=createGetter(false,true);const D=createGetter(true);const I=createGetter(true,true);const M=createArrayInstrumentations();function createArrayInstrumentations(){const e={};["includes","indexOf","lastIndexOf"].forEach((t=>{e[t]=function(...e){const r=toRaw(this);for(let e=0,t=this.length;e<t;e++)track(r,"get",e+"");const s=r[t](...e);return-1===s||false===s?r[t](...e.map(toRaw)):s}}));["push","pop","shift","unshift","splice"].forEach((t=>{e[t]=function(...e){pauseTracking();const r=toRaw(this)[t].apply(this,e);resetTracking();return r}}));return e}function createGetter(e=false,r=false){return function get(s,o,f){if("__v_isReactive"===o)return!e;if("__v_isReadonly"===o)return e;if("__v_isShallow"===o)return r;if("__v_raw"===o&&f===(e?r?Q:L:r?J:H).get(s))return s;const u=t(s);if(!e&&u&&i(M,o))return Reflect.get(M,o,f);const l=Reflect.get(s,o,f);if(c(o)?S.has(o):b(o))return l;e||track(s,"get",o);return r?l:isRef(l)?u&&n(o)?l:l.value:a(l)?e?readonly(l):reactive(l):l}}const T=createSetter();const $=createSetter(true);function createSetter(e=false){return function set(r,s,o,c){let a=r[s];if(isReadonly(a)&&isRef(a)&&!isRef(o))return false;if(!e){if(!isShallow(o)&&!isReadonly(o)){a=toRaw(a);o=toRaw(o)}if(!t(r)&&isRef(a)&&!isRef(o)){a.value=o;return true}}const u=t(r)&&n(s)?Number(s)<r.length:i(r,s);const l=Reflect.set(r,s,o,c);r===toRaw(c)&&(u?f(o,a)&&trigger(r,"set",s,o,a):trigger(r,"add",s,o));return l}}function deleteProperty(e,t){const r=i(e,t);const s=e[t];const n=Reflect.deleteProperty(e,t);n&&r&&trigger(e,"delete",t,void 0,s);return n}function has(e,t){const r=Reflect.has(e,t);c(t)&&S.has(t)||track(e,"has",t);return r}function ownKeys(e){track(e,"iterate",t(e)?"length":E);return Reflect.ownKeys(e)}const x={get:V,set:T,deleteProperty:deleteProperty,has:has,ownKeys:ownKeys};const j={get:D,set(e,t){"production"!==process.env.NODE_ENV&&warn(`Set operation on key "${String(t)}" failed: target is readonly.`,e);return true},deleteProperty(e,t){"production"!==process.env.NODE_ENV&&warn(`Delete operation on key "${String(t)}" failed: target is readonly.`,e);return true}};const P=e({},x,{get:O,set:$});const z=e({},j,{get:I});const toShallow=e=>e;const getProto=e=>Reflect.getPrototypeOf(e);function get$1(e,t,r=false,s=false){e=e.__v_raw;const n=toRaw(e);const o=toRaw(t);if(!r){t!==o&&track(n,"get",t);track(n,"get",o)}const{has:c}=getProto(n);const i=s?toShallow:r?toReadonly:toReactive;if(c.call(n,t))return i(e.get(t));if(c.call(n,o))return i(e.get(o));e!==n&&e.get(t)}function has$1(e,t=false){const r=this.__v_raw;const s=toRaw(r);const n=toRaw(e);if(!t){e!==n&&track(s,"has",e);track(s,"has",n)}return e===n?r.has(e):r.has(e)||r.has(n)}function size(e,t=false){e=e.__v_raw;!t&&track(toRaw(e),"iterate",E);return Reflect.get(e,"size",e)}function add(e){e=toRaw(e);const t=toRaw(this);const r=getProto(t);const s=r.has.call(t,e);if(!s){t.add(e);trigger(t,"add",e,e)}return this}function set$1(e,t){t=toRaw(t);const r=toRaw(this);const{has:s,get:n}=getProto(r);let o=s.call(r,e);if(o)"production"!==process.env.NODE_ENV&&checkIdentityKeys(r,s,e);else{e=toRaw(e);o=s.call(r,e)}const c=n.call(r,e);r.set(e,t);o?f(t,c)&&trigger(r,"set",e,t,c):trigger(r,"add",e,t);return this}function deleteEntry(e){const t=toRaw(this);const{has:r,get:s}=getProto(t);let n=r.call(t,e);if(n)"production"!==process.env.NODE_ENV&&checkIdentityKeys(t,r,e);else{e=toRaw(e);n=r.call(t,e)}const o=s?s.call(t,e):void 0;const c=t.delete(e);n&&trigger(t,"delete",e,void 0,o);return c}function clear(){const e=toRaw(this);const t=0!==e.size;const r="production"!==process.env.NODE_ENV?s(e)?new Map(e):new Set(e):void 0;const n=e.clear();t&&trigger(e,"clear",void 0,void 0,r);return n}function createForEach(e,t){return function forEach(r,s){const n=this;const o=n.__v_raw;const c=toRaw(o);const i=t?toShallow:e?toReadonly:toReactive;!e&&track(c,"iterate",E);return o.forEach(((e,t)=>r.call(s,i(e),i(t),n)))}}function createIterableMethod(e,t,r){return function(...n){const o=this.__v_raw;const c=toRaw(o);const i=s(c);const a="entries"===e||e===Symbol.iterator&&i;const f="keys"===e&&i;const u=o[e](...n);const l=r?toShallow:t?toReadonly:toReactive;!t&&track(c,"iterate",f?k:E);return{next(){const{value:e,done:t}=u.next();return t?{value:e,done:t}:{value:a?[l(e[0]),l(e[1])]:l(e),done:t}},[Symbol.iterator](){return this}}}}function createReadonlyMethod(e){return function(...t){if("production"!==process.env.NODE_ENV){const r=t[0]?`on key "${t[0]}" `:"";console.warn(`${u(e)} operation ${r}failed: target is readonly.`,toRaw(this))}return"delete"!==e&&this}}function createInstrumentations(){const e={get(e){return get$1(this,e)},get size(){return size(this)},has:has$1,add:add,set:set$1,delete:deleteEntry,clear:clear,forEach:createForEach(false,false)};const t={get(e){return get$1(this,e,false,true)},get size(){return size(this)},has:has$1,add:add,set:set$1,delete:deleteEntry,clear:clear,forEach:createForEach(false,true)};const r={get(e){return get$1(this,e,true)},get size(){return size(this,true)},has(e){return has$1.call(this,e,true)},add:createReadonlyMethod("add"),set:createReadonlyMethod("set"),delete:createReadonlyMethod("delete"),clear:createReadonlyMethod("clear"),forEach:createForEach(true,false)};const s={get(e){return get$1(this,e,true,true)},get size(){return size(this,true)},has(e){return has$1.call(this,e,true)},add:createReadonlyMethod("add"),set:createReadonlyMethod("set"),delete:createReadonlyMethod("delete"),clear:createReadonlyMethod("clear"),forEach:createForEach(true,true)};const n=["keys","values","entries",Symbol.iterator];n.forEach((n=>{e[n]=createIterableMethod(n,false,false);r[n]=createIterableMethod(n,true,false);t[n]=createIterableMethod(n,false,true);s[n]=createIterableMethod(n,true,true)}));return[e,r,t,s]}const[C,G,W,K]=createInstrumentations();function createInstrumentationGetter(e,t){const r=t?e?K:W:e?G:C;return(t,s,n)=>"__v_isReactive"===s?!e:"__v_isReadonly"===s?e:"__v_raw"===s?t:Reflect.get(i(r,s)&&s in t?r:t,s,n)}const A={get:createInstrumentationGetter(false,false)};const F={get:createInstrumentationGetter(false,true)};const q={get:createInstrumentationGetter(true,false)};const B={get:createInstrumentationGetter(true,true)};function checkIdentityKeys(e,t,r){const s=toRaw(r);if(s!==r&&t.call(e,s)){const t=l(e);console.warn(`Reactive ${t} contains both the raw and reactive versions of the same object${"Map"===t?" as keys":""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`)}}const H=new WeakMap;const J=new WeakMap;const L=new WeakMap;const Q=new WeakMap;function targetTypeMap(e){switch(e){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function getTargetType(e){return e.__v_skip||!Object.isExtensible(e)?0:targetTypeMap(l(e))}function reactive(e){return isReadonly(e)?e:createReactiveObject(e,false,x,A,H)}function shallowReactive(e){return createReactiveObject(e,false,P,F,J)}function readonly(e){return createReactiveObject(e,true,j,q,L)}function shallowReadonly(e){return createReactiveObject(e,true,z,B,Q)}function createReactiveObject(e,t,r,s,n){if(!a(e)){"production"!==process.env.NODE_ENV&&console.warn(`value cannot be made reactive: ${String(e)}`);return e}if(e.__v_raw&&!(t&&e.__v_isReactive))return e;const o=n.get(e);if(o)return o;const c=getTargetType(e);if(0===c)return e;const i=new Proxy(e,2===c?s:r);n.set(e,i);return i}function isReactive(e){return isReadonly(e)?isReactive(e.__v_raw):!!(e&&e.__v_isReactive)}function isReadonly(e){return!!(e&&e.__v_isReadonly)}function isShallow(e){return!!(e&&e.__v_isShallow)}function isProxy(e){return isReactive(e)||isReadonly(e)}function toRaw(e){const t=e&&e.__v_raw;return t?toRaw(t):e}function markRaw(e){h(e,"__v_skip",true);return e}const toReactive=e=>a(e)?reactive(e):e;const toReadonly=e=>a(e)?readonly(e):e;function trackRefValue(e){if(m&&y){e=toRaw(e);"production"!==process.env.NODE_ENV?trackEffects(e.dep||(e.dep=createDep()),{target:e,type:"get",key:"value"}):trackEffects(e.dep||(e.dep=createDep()))}}function triggerRefValue(e,t){e=toRaw(e);e.dep&&("production"!==process.env.NODE_ENV?triggerEffects(e.dep,{target:e,type:"set",key:"value",newValue:t}):triggerEffects(e.dep))}function isRef(e){return!!(e&&true===e.__v_isRef)}function ref(e){return createRef(e,false)}function shallowRef(e){return createRef(e,true)}function createRef(e,t){return isRef(e)?e:new RefImpl(e,t)}class RefImpl{constructor(e,t){this.__v_isShallow=t;this.dep=void 0;this.__v_isRef=true;this._rawValue=t?e:toRaw(e);this._value=t?e:toReactive(e)}get value(){trackRefValue(this);return this._value}set value(e){const t=this.__v_isShallow||isShallow(e)||isReadonly(e);e=t?e:toRaw(e);if(f(e,this._rawValue)){this._rawValue=e;this._value=t?e:toReactive(e);triggerRefValue(this,e)}}}function triggerRef(e){triggerRefValue(e,"production"!==process.env.NODE_ENV?e.value:void 0)}function unref(e){return isRef(e)?e.value:e}const U={get:(e,t,r)=>unref(Reflect.get(e,t,r)),set:(e,t,r,s)=>{const n=e[t];if(isRef(n)&&!isRef(r)){n.value=r;return true}return Reflect.set(e,t,r,s)}};function proxyRefs(e){return isReactive(e)?e:new Proxy(e,U)}class CustomRefImpl{constructor(e){this.dep=void 0;this.__v_isRef=true;const{get:t,set:r}=e((()=>trackRefValue(this)),(()=>triggerRefValue(this)));this._get=t;this._set=r}get value(){return this._get()}set value(e){this._set(e)}}function customRef(e){return new CustomRefImpl(e)}function toRefs(e){"production"===process.env.NODE_ENV||isProxy(e)||console.warn("toRefs() expects a reactive object but received a plain one.");const r=t(e)?new Array(e.length):{};for(const t in e)r[t]=toRef(e,t);return r}class ObjectRefImpl{constructor(e,t,r){this._object=e;this._key=t;this._defaultValue=r;this.__v_isRef=true}get value(){const e=this._object[this._key];return void 0===e?this._defaultValue:e}set value(e){this._object[this._key]=e}}function toRef(e,t,r){const s=e[t];return isRef(s)?s:new ObjectRefImpl(e,t,r)}var X;class ComputedRefImpl{constructor(e,t,r,s){this._setter=t;this.dep=void 0;this.__v_isRef=true;this[X]=false;this._dirty=true;this.effect=new ReactiveEffect(e,(()=>{if(!this._dirty){this._dirty=true;triggerRefValue(this)}}));this.effect.computed=this;this.effect.active=this._cacheable=!s;this.__v_isReadonly=r}get value(){const e=toRaw(this);trackRefValue(e);if(e._dirty||!e._cacheable){e._dirty=false;e._value=e.effect.run()}return e._value}set value(e){this._setter(e)}}X="__v_isReadonly";function computed(e,t,r=false){let s;let n;const o=d(e);if(o){s=e;n="production"!==process.env.NODE_ENV?()=>{console.warn("Write operation failed: computed value is readonly")}:p}else{s=e.get;n=e.set}const c=new ComputedRefImpl(s,n,o||!n,r);if("production"!==process.env.NODE_ENV&&t&&!r){c.effect.onTrack=t.onTrack;c.effect.onTrigger=t.onTrigger}return c}var Y;const Z=Promise.resolve();const ee=[];let te=false;const scheduler=e=>{ee.push(e);if(!te){te=true;Z.then(flush)}};const flush=()=>{for(let e=0;e<ee.length;e++)ee[e]();ee.length=0;te=false};class DeferredComputedRefImpl{constructor(e){this.dep=void 0;this._dirty=true;this.__v_isRef=true;this[Y]=true;let t;let r=false;let s=false;this.effect=new ReactiveEffect(e,(e=>{if(this.dep){if(e){t=this._value;r=true}else if(!s){const e=r?t:this._value;s=true;r=false;scheduler((()=>{this.effect.active&&this._get()!==e&&triggerRefValue(this);s=false}))}for(const e of this.dep)e.computed instanceof DeferredComputedRefImpl&&e.scheduler(true)}this._dirty=true}));this.effect.computed=this}_get(){if(this._dirty){this._dirty=false;return this._value=this.effect.run()}return this._value}get value(){trackRefValue(this);return toRaw(this)._get()}}Y="__v_isReadonly";function deferredComputed(e){return new DeferredComputedRefImpl(e)}export{EffectScope,E as ITERATE_KEY,ReactiveEffect,computed,customRef,deferredComputed,effect,effectScope,enableTracking,getCurrentScope,isProxy,isReactive,isReadonly,isRef,isShallow,markRaw,onScopeDispose,pauseTracking,proxyRefs,reactive,readonly,ref,resetTracking,shallowReactive,shallowReadonly,shallowRef,stop,toRaw,toRef,toRefs,track,trigger,triggerRef,unref};

