import{warn as e,camelize as t,callWithAsyncErrorHandling as n,defineComponent as s,nextTick as o,createVNode as r,getCurrentInstance as i,watchPostEffect as a,onMounted as l,onUnmounted as c,Fragment as u,Static as p,h as d,BaseTransition as f,useTransitionState as m,onUpdated as h,toRaw as v,getTransitionRawChildren as g,setTransitionHooks as _,resolveTransitionHooks as C,createRenderer as y,createHydrationRenderer as b,isRuntimeOnly as E}from"@vue/runtime-core";export*from"@vue/runtime-core";import{isString as S,isArray as N,hyphenate as T,capitalize as w,isSpecialBooleanAttr as V,includeBooleanAttr as O,isOn as k,isModelListener as P,isFunction as A,toNumber as x,camelize as D,extend as L,EMPTY_OBJ as R,isObject as M,invokeArrayFns as $,looseIndexOf as F,isSet as j,looseEqual as I,isHTMLTag as H,isSVGTag as B}from"@vue/shared";const U="http://www.w3.org/2000/svg";const z="undefined"!==typeof document?document:null;const q=z&&z.createElement("template");const G={insert:(e,t,n)=>{t.insertBefore(e,n||null)},remove:e=>{const t=e.parentNode;t&&t.removeChild(e)},createElement:(e,t,n,s)=>{const o=t?z.createElementNS(U,e):z.createElement(e,n?{is:n}:void 0);"select"===e&&s&&null!=s.multiple&&o.setAttribute("multiple",s.multiple);return o},createText:e=>z.createTextNode(e),createComment:e=>z.createComment(e),setText:(e,t)=>{e.nodeValue=t},setElementText:(e,t)=>{e.textContent=t},parentNode:e=>e.parentNode,nextSibling:e=>e.nextSibling,querySelector:e=>z.querySelector(e),setScopeId(e,t){e.setAttribute(t,"")},insertStaticContent(e,t,n,s,o,r){const i=n?n.previousSibling:t.lastChild;if(o&&(o===r||o.nextSibling))while(true){t.insertBefore(o.cloneNode(true),n);if(o===r||!(o=o.nextSibling))break}else{q.innerHTML=s?`<svg>${e}</svg>`:e;const o=q.content;if(s){const e=o.firstChild;while(e.firstChild)o.appendChild(e.firstChild);o.removeChild(e)}t.insertBefore(o,n)}return[i?i.nextSibling:t.firstChild,n?n.previousSibling:t.lastChild]}};function patchClass(e,t,n){const s=e._vtc;s&&(t=(t?[t,...s]:[...s]).join(" "));null==t?e.removeAttribute("class"):n?e.setAttribute("class",t):e.className=t}function patchStyle(e,t,n){const s=e.style;const o=S(n);if(n&&!o){for(const e in n)setStyle(s,e,n[e]);if(t&&!S(t))for(const e in t)null==n[e]&&setStyle(s,e,"")}else{const r=s.display;o?t!==n&&(s.cssText=n):t&&e.removeAttribute("style");"_vod"in e&&(s.display=r)}}const K=/[^\\];\s*$/;const W=/\s*!important$/;function setStyle(t,n,s){if(N(s))s.forEach((e=>setStyle(t,n,e)));else{null==s&&(s="");"production"!==process.env.NODE_ENV&&K.test(s)&&e(`Unexpected semicolon at the end of '${n}' style value: '${s}'`);if(n.startsWith("--"))t.setProperty(n,s);else{const e=autoPrefix(t,n);W.test(s)?t.setProperty(T(e),s.replace(W,""),"important"):t[e]=s}}}const X=["Webkit","Moz","ms"];const J={};function autoPrefix(e,n){const s=J[n];if(s)return s;let o=t(n);if("filter"!==o&&o in e)return J[n]=o;o=w(o);for(let t=0;t<X.length;t++){const s=X[t]+o;if(s in e)return J[n]=s}return n}const Q="http://www.w3.org/1999/xlink";function patchAttr(e,t,n,s,o){if(s&&t.startsWith("xlink:"))null==n?e.removeAttributeNS(Q,t.slice(6,t.length)):e.setAttributeNS(Q,t,n);else{const s=V(t);null==n||s&&!O(n)?e.removeAttribute(t):e.setAttribute(t,s?"":n)}}function patchDOMProp(t,n,s,o,r,i,a){if("innerHTML"===n||"textContent"===n){o&&a(o,r,i);t[n]=null==s?"":s;return}if("value"===n&&"PROGRESS"!==t.tagName&&!t.tagName.includes("-")){t._value=s;const e=null==s?"":s;t.value===e&&"OPTION"!==t.tagName||(t.value=e);null==s&&t.removeAttribute(n);return}let l=false;if(""===s||null==s){const e=typeof t[n];if("boolean"===e)s=O(s);else if(null==s&&"string"===e){s="";l=true}else if("number"===e){s=0;l=true}}try{t[n]=s}catch(o){"production"===process.env.NODE_ENV||l||e(`Failed setting prop "${n}" on <${t.tagName.toLowerCase()}>: value ${s} is invalid.`,o)}l&&t.removeAttribute(n)}function addEventListener(e,t,n,s){e.addEventListener(t,n,s)}function removeEventListener(e,t,n,s){e.removeEventListener(t,n,s)}function patchEvent(e,t,n,s,o=null){const r=e._vei||(e._vei={});const i=r[t];if(s&&i)i.value=s;else{const[n,a]=parseName(t);if(s){const i=r[t]=createInvoker(s,o);addEventListener(e,n,i,a)}else if(i){removeEventListener(e,n,i,a);r[t]=void 0}}}const Y=/(?:Once|Passive|Capture)$/;function parseName(e){let t;if(Y.test(e)){t={};let n;while(n=e.match(Y)){e=e.slice(0,e.length-n[0].length);t[n[0].toLowerCase()]=true}}const n=":"===e[2]?e.slice(3):T(e.slice(2));return[n,t]}let Z=0;const ee=Promise.resolve();const getNow=()=>Z||(ee.then((()=>Z=0)),Z=Date.now());function createInvoker(e,t){const invoker=e=>{if(e._vts){if(e._vts<=invoker.attached)return}else e._vts=Date.now();n(patchStopImmediatePropagation(e,invoker.value),t,5,[e])};invoker.value=e;invoker.attached=getNow();return invoker}function patchStopImmediatePropagation(e,t){if(N(t)){const n=e.stopImmediatePropagation;e.stopImmediatePropagation=()=>{n.call(e);e._stopped=true};return t.map((e=>t=>!t._stopped&&e&&e(t)))}return t}const te=/^on[a-z]/;const patchProp=(e,t,n,s,o=false,r,i,a,l)=>{if("class"===t)patchClass(e,s,o);else if("style"===t)patchStyle(e,n,s);else if(k(t))P(t)||patchEvent(e,t,n,s,i);else if("."===t[0]?(t=t.slice(1),true):"^"===t[0]?(t=t.slice(1),false):shouldSetAsProp(e,t,s,o))patchDOMProp(e,t,s,r,i,a,l);else{"true-value"===t?e._trueValue=s:"false-value"===t&&(e._falseValue=s);patchAttr(e,t,s,o)}};function shouldSetAsProp(e,t,n,s){return s?"innerHTML"===t||"textContent"===t||!!(t in e&&te.test(t)&&A(n)):"spellcheck"!==t&&"draggable"!==t&&"translate"!==t&&("form"!==t&&(("list"!==t||"INPUT"!==e.tagName)&&(("type"!==t||"TEXTAREA"!==e.tagName)&&((!te.test(t)||!S(n))&&t in e))))}function defineCustomElement(e,t){const n=s(e);class VueCustomElement extends VueElement{constructor(e){super(n,e,t)}}VueCustomElement.def=n;return VueCustomElement}const defineSSRCustomElement=e=>defineCustomElement(e,hydrate);const ne="undefined"!==typeof HTMLElement?HTMLElement:class{};class VueElement extends ne{constructor(t,n={},s){super();this._def=t;this._props=n;this._instance=null;this._connected=false;this._resolved=false;this._numberProps=null;if(this.shadowRoot&&s)s(this._createVNode(),this.shadowRoot);else{"production"!==process.env.NODE_ENV&&this.shadowRoot&&e("Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use `defineSSRCustomElement`.");this.attachShadow({mode:"open"});this._def.__asyncLoader||this._resolveProps(this._def)}}connectedCallback(){this._connected=true;this._instance||(this._resolved?this._update():this._resolveDef())}disconnectedCallback(){this._connected=false;o((()=>{if(!this._connected){render(null,this.shadowRoot);this._instance=null}}))}_resolveDef(){this._resolved=true;for(let e=0;e<this.attributes.length;e++)this._setAttr(this.attributes[e].name);new MutationObserver((e=>{for(const t of e)this._setAttr(t.attributeName)})).observe(this,{attributes:true});const resolve=(e,t=false)=>{const{props:n,styles:s}=e;let o;if(n&&!N(n))for(const e in n){const t=n[e];if(t===Number||t&&t.type===Number){e in this._props&&(this._props[e]=x(this._props[e]));(o||(o=Object.create(null)))[D(e)]=true}}this._numberProps=o;t&&this._resolveProps(e);this._applyStyles(s);this._update()};const e=this._def.__asyncLoader;e?e().then((e=>resolve(e,true))):resolve(this._def)}_resolveProps(e){const{props:t}=e;const n=N(t)?t:Object.keys(t||{});for(const e of Object.keys(this))"_"!==e[0]&&n.includes(e)&&this._setProp(e,this[e],true,false);for(const e of n.map(D))Object.defineProperty(this,e,{get(){return this._getProp(e)},set(t){this._setProp(e,t)}})}_setAttr(e){let t=this.getAttribute(e);const n=D(e);this._numberProps&&this._numberProps[n]&&(t=x(t));this._setProp(n,t,false)}_getProp(e){return this._props[e]}_setProp(e,t,n=true,s=true){if(t!==this._props[e]){this._props[e]=t;s&&this._instance&&this._update();n&&(true===t?this.setAttribute(T(e),""):"string"===typeof t||"number"===typeof t?this.setAttribute(T(e),t+""):t||this.removeAttribute(T(e)))}}_update(){render(this._createVNode(),this.shadowRoot)}_createVNode(){const e=r(this._def,L({},this._props));this._instance||(e.ce=e=>{this._instance=e;e.isCE=true;"production"!==process.env.NODE_ENV&&(e.ceReload=e=>{if(this._styles){this._styles.forEach((e=>this.shadowRoot.removeChild(e)));this._styles.length=0}this._applyStyles(e);this._instance=null;this._update()});const dispatch=(e,t)=>{this.dispatchEvent(new CustomEvent(e,{detail:t}))};e.emit=(e,...t)=>{dispatch(e,t);T(e)!==e&&dispatch(T(e),t)};let t=this;while(t=t&&(t.parentNode||t.host))if(t instanceof VueElement){e.parent=t._instance;e.provides=t._instance.provides;break}});return e}_applyStyles(e){e&&e.forEach((e=>{const t=document.createElement("style");t.textContent=e;this.shadowRoot.appendChild(t);"production"!==process.env.NODE_ENV&&(this._styles||(this._styles=[])).push(t)}))}}function useCssModule(t="$style"){{const n=i();if(!n){"production"!==process.env.NODE_ENV&&e("useCssModule must be called inside setup()");return R}const s=n.type.__cssModules;if(!s){"production"!==process.env.NODE_ENV&&e("Current instance does not have CSS modules injected.");return R}const o=s[t];if(!o){"production"!==process.env.NODE_ENV&&e(`Current instance does not have CSS module named "${t}".`);return R}return o}}function useCssVars(t){const n=i();if(!n){"production"!==process.env.NODE_ENV&&e("useCssVars is called without current active component instance.");return}const s=n.ut=(e=t(n.proxy))=>{Array.from(document.querySelectorAll(`[data-v-owner="${n.uid}"]`)).forEach((t=>setVarsOnNode(t,e)))};const setVars=()=>{const e=t(n.proxy);setVarsOnVNode(n.subTree,e);s(e)};a(setVars);l((()=>{const e=new MutationObserver(setVars);e.observe(n.subTree.el.parentNode,{childList:true});c((()=>e.disconnect()))}))}function setVarsOnVNode(e,t){if(128&e.shapeFlag){const n=e.suspense;e=n.activeBranch;n.pendingBranch&&!n.isHydrating&&n.effects.push((()=>{setVarsOnVNode(n.activeBranch,t)}))}while(e.component)e=e.component.subTree;if(1&e.shapeFlag&&e.el)setVarsOnNode(e.el,t);else if(e.type===u)e.children.forEach((e=>setVarsOnVNode(e,t)));else if(e.type===p){let{el:n,anchor:s}=e;while(n){setVarsOnNode(n,t);if(n===s)break;n=n.nextSibling}}}function setVarsOnNode(e,t){if(1===e.nodeType){const n=e.style;for(const e in t)n.setProperty(`--${e}`,t[e])}}const se="transition";const oe="animation";const Transition=(e,{slots:t})=>d(f,resolveTransitionProps(e),t);Transition.displayName="Transition";const re={name:String,type:String,css:{type:Boolean,default:true},duration:[String,Number,Object],enterFromClass:String,enterActiveClass:String,enterToClass:String,appearFromClass:String,appearActiveClass:String,appearToClass:String,leaveFromClass:String,leaveActiveClass:String,leaveToClass:String};const ie=Transition.props=L({},f.props,re);const callHook=(e,t=[])=>{N(e)?e.forEach((e=>e(...t))):e&&e(...t)};const hasExplicitCallback=e=>!!e&&(N(e)?e.some((e=>e.length>1)):e.length>1);function resolveTransitionProps(e){const t={};for(const n in e)n in re||(t[n]=e[n]);if(false===e.css)return t;const{name:n="v",type:s,duration:o,enterFromClass:r=`${n}-enter-from`,enterActiveClass:i=`${n}-enter-active`,enterToClass:a=`${n}-enter-to`,appearFromClass:l=r,appearActiveClass:c=i,appearToClass:u=a,leaveFromClass:p=`${n}-leave-from`,leaveActiveClass:d=`${n}-leave-active`,leaveToClass:f=`${n}-leave-to`}=e;const m=normalizeDuration(o);const h=m&&m[0];const v=m&&m[1];const{onBeforeEnter:g,onEnter:_,onEnterCancelled:C,onLeave:y,onLeaveCancelled:b,onBeforeAppear:E=g,onAppear:S=_,onAppearCancelled:N=C}=t;const finishEnter=(e,t,n)=>{removeTransitionClass(e,t?u:a);removeTransitionClass(e,t?c:i);n&&n()};const finishLeave=(e,t)=>{e._isLeaving=false;removeTransitionClass(e,p);removeTransitionClass(e,f);removeTransitionClass(e,d);t&&t()};const makeEnterHook=e=>(t,n)=>{const o=e?S:_;const resolve=()=>finishEnter(t,e,n);callHook(o,[t,resolve]);nextFrame((()=>{removeTransitionClass(t,e?l:r);addTransitionClass(t,e?u:a);hasExplicitCallback(o)||whenTransitionEnds(t,s,h,resolve)}))};return L(t,{onBeforeEnter(e){callHook(g,[e]);addTransitionClass(e,r);addTransitionClass(e,i)},onBeforeAppear(e){callHook(E,[e]);addTransitionClass(e,l);addTransitionClass(e,c)},onEnter:makeEnterHook(false),onAppear:makeEnterHook(true),onLeave(e,t){e._isLeaving=true;const resolve=()=>finishLeave(e,t);addTransitionClass(e,p);forceReflow();addTransitionClass(e,d);nextFrame((()=>{if(e._isLeaving){removeTransitionClass(e,p);addTransitionClass(e,f);hasExplicitCallback(y)||whenTransitionEnds(e,s,v,resolve)}}));callHook(y,[e,resolve])},onEnterCancelled(e){finishEnter(e,false);callHook(C,[e])},onAppearCancelled(e){finishEnter(e,true);callHook(N,[e])},onLeaveCancelled(e){finishLeave(e);callHook(b,[e])}})}function normalizeDuration(e){if(null==e)return null;if(M(e))return[NumberOf(e.enter),NumberOf(e.leave)];{const t=NumberOf(e);return[t,t]}}function NumberOf(e){const t=x(e);"production"!==process.env.NODE_ENV&&validateDuration(t);return t}function validateDuration(t){"number"!==typeof t?e(`<transition> explicit duration is not a valid number - got ${JSON.stringify(t)}.`):isNaN(t)&&e("<transition> explicit duration is NaN - the duration expression might be incorrect.")}function addTransitionClass(e,t){t.split(/\s+/).forEach((t=>t&&e.classList.add(t)));(e._vtc||(e._vtc=new Set)).add(t)}function removeTransitionClass(e,t){t.split(/\s+/).forEach((t=>t&&e.classList.remove(t)));const{_vtc:n}=e;if(n){n.delete(t);n.size||(e._vtc=void 0)}}function nextFrame(e){requestAnimationFrame((()=>{requestAnimationFrame(e)}))}let ae=0;function whenTransitionEnds(e,t,n,s){const o=e._endId=++ae;const resolveIfNotStale=()=>{o===e._endId&&s()};if(n)return setTimeout(resolveIfNotStale,n);const{type:r,timeout:i,propCount:a}=getTransitionInfo(e,t);if(!r)return s();const l=r+"end";let c=0;const end=()=>{e.removeEventListener(l,onEnd);resolveIfNotStale()};const onEnd=t=>{t.target===e&&++c>=a&&end()};setTimeout((()=>{c<a&&end()}),i+1);e.addEventListener(l,onEnd)}function getTransitionInfo(e,t){const n=window.getComputedStyle(e);const getStyleProperties=e=>(n[e]||"").split(", ");const s=getStyleProperties(`${se}Delay`);const o=getStyleProperties(`${se}Duration`);const r=getTimeout(s,o);const i=getStyleProperties(`${oe}Delay`);const a=getStyleProperties(`${oe}Duration`);const l=getTimeout(i,a);let c=null;let u=0;let p=0;if(t===se){if(r>0){c=se;u=r;p=o.length}}else if(t===oe){if(l>0){c=oe;u=l;p=a.length}}else{u=Math.max(r,l);c=u>0?r>l?se:oe:null;p=c?c===se?o.length:a.length:0}const d=c===se&&/\b(transform|all)(,|$)/.test(getStyleProperties(`${se}Property`).toString());return{type:c,timeout:u,propCount:p,hasTransform:d}}function getTimeout(e,t){while(e.length<t.length)e=e.concat(e);return Math.max(...t.map(((t,n)=>toMs(t)+toMs(e[n]))))}function toMs(e){return 1e3*Number(e.slice(0,-1).replace(",","."))}function forceReflow(){return document.body.offsetHeight}const le=new WeakMap;const ce=new WeakMap;const ue={name:"TransitionGroup",props:L({},ie,{tag:String,moveClass:String}),setup(t,{slots:n}){const s=i();const o=m();let a;let l;h((()=>{if(!a.length)return;const e=t.moveClass||`${t.name||"v"}-move`;if(!hasCSSTransform(a[0].el,s.vnode.el,e))return;a.forEach(callPendingCbs);a.forEach(recordPosition);const n=a.filter(applyTranslation);forceReflow();n.forEach((t=>{const n=t.el;const s=n.style;addTransitionClass(n,e);s.transform=s.webkitTransform=s.transitionDuration="";const o=n._moveCb=t=>{if((!t||t.target===n)&&(!t||/transform$/.test(t.propertyName))){n.removeEventListener("transitionend",o);n._moveCb=null;removeTransitionClass(n,e)}};n.addEventListener("transitionend",o)}))}));return()=>{const i=v(t);const c=resolveTransitionProps(i);let p=i.tag||u;a=l;l=n.default?g(n.default()):[];for(let t=0;t<l.length;t++){const n=l[t];null!=n.key?_(n,C(n,c,o,s)):"production"!==process.env.NODE_ENV&&e("<TransitionGroup> children must be keyed.")}if(a)for(let e=0;e<a.length;e++){const t=a[e];_(t,C(t,c,o,s));le.set(t,t.el.getBoundingClientRect())}return r(p,null,l)}}};const pe=ue;function callPendingCbs(e){const t=e.el;t._moveCb&&t._moveCb();t._enterCb&&t._enterCb()}function recordPosition(e){ce.set(e,e.el.getBoundingClientRect())}function applyTranslation(e){const t=le.get(e);const n=ce.get(e);const s=t.left-n.left;const o=t.top-n.top;if(s||o){const t=e.el.style;t.transform=t.webkitTransform=`translate(${s}px,${o}px)`;t.transitionDuration="0s";return e}}function hasCSSTransform(e,t,n){const s=e.cloneNode();e._vtc&&e._vtc.forEach((e=>{e.split(/\s+/).forEach((e=>e&&s.classList.remove(e)))}));n.split(/\s+/).forEach((e=>e&&s.classList.add(e)));s.style.display="none";const o=1===t.nodeType?t:t.parentNode;o.appendChild(s);const{hasTransform:r}=getTransitionInfo(s);o.removeChild(s);return r}const getModelAssigner=e=>{const t=e.props["onUpdate:modelValue"]||false;return N(t)?e=>$(t,e):t};function onCompositionStart(e){e.target.composing=true}function onCompositionEnd(e){const t=e.target;if(t.composing){t.composing=false;t.dispatchEvent(new Event("input"))}}const de={created(e,{modifiers:{lazy:t,trim:n,number:s}},o){e._assign=getModelAssigner(o);const r=s||o.props&&"number"===o.props.type;addEventListener(e,t?"change":"input",(t=>{if(t.target.composing)return;let s=e.value;n&&(s=s.trim());r&&(s=x(s));e._assign(s)}));n&&addEventListener(e,"change",(()=>{e.value=e.value.trim()}));if(!t){addEventListener(e,"compositionstart",onCompositionStart);addEventListener(e,"compositionend",onCompositionEnd);addEventListener(e,"change",onCompositionEnd)}},mounted(e,{value:t}){e.value=null==t?"":t},beforeUpdate(e,{value:t,modifiers:{lazy:n,trim:s,number:o}},r){e._assign=getModelAssigner(r);if(e.composing)return;if(document.activeElement===e&&"range"!==e.type){if(n)return;if(s&&e.value.trim()===t)return;if((o||"number"===e.type)&&x(e.value)===t)return}const i=null==t?"":t;e.value!==i&&(e.value=i)}};const fe={deep:true,created(e,t,n){e._assign=getModelAssigner(n);addEventListener(e,"change",(()=>{const t=e._modelValue;const n=getValue(e);const s=e.checked;const o=e._assign;if(N(t)){const e=F(t,n);const r=-1!==e;if(s&&!r)o(t.concat(n));else if(!s&&r){const n=[...t];n.splice(e,1);o(n)}}else if(j(t)){const e=new Set(t);s?e.add(n):e.delete(n);o(e)}else o(getCheckboxValue(e,s))}))},mounted:setChecked,beforeUpdate(e,t,n){e._assign=getModelAssigner(n);setChecked(e,t,n)}};function setChecked(e,{value:t,oldValue:n},s){e._modelValue=t;N(t)?e.checked=F(t,s.props.value)>-1:j(t)?e.checked=t.has(s.props.value):t!==n&&(e.checked=I(t,getCheckboxValue(e,true)))}const me={created(e,{value:t},n){e.checked=I(t,n.props.value);e._assign=getModelAssigner(n);addEventListener(e,"change",(()=>{e._assign(getValue(e))}))},beforeUpdate(e,{value:t,oldValue:n},s){e._assign=getModelAssigner(s);t!==n&&(e.checked=I(t,s.props.value))}};const he={deep:true,created(e,{value:t,modifiers:{number:n}},s){const o=j(t);addEventListener(e,"change",(()=>{const t=Array.prototype.filter.call(e.options,(e=>e.selected)).map((e=>n?x(getValue(e)):getValue(e)));e._assign(e.multiple?o?new Set(t):t:t[0])}));e._assign=getModelAssigner(s)},mounted(e,{value:t}){setSelected(e,t)},beforeUpdate(e,t,n){e._assign=getModelAssigner(n)},updated(e,{value:t}){setSelected(e,t)}};function setSelected(t,n){const s=t.multiple;if(!s||N(n)||j(n)){for(let e=0,o=t.options.length;e<o;e++){const o=t.options[e];const r=getValue(o);if(s)N(n)?o.selected=F(n,r)>-1:o.selected=n.has(r);else if(I(getValue(o),n)){t.selectedIndex!==e&&(t.selectedIndex=e);return}}s||-1===t.selectedIndex||(t.selectedIndex=-1)}else"production"!==process.env.NODE_ENV&&e(`<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(n).slice(8,-1)}.`)}function getValue(e){return"_value"in e?e._value:e.value}function getCheckboxValue(e,t){const n=t?"_trueValue":"_falseValue";return n in e?e[n]:t}const ve={created(e,t,n){callModelHook(e,t,n,null,"created")},mounted(e,t,n){callModelHook(e,t,n,null,"mounted")},beforeUpdate(e,t,n,s){callModelHook(e,t,n,s,"beforeUpdate")},updated(e,t,n,s){callModelHook(e,t,n,s,"updated")}};function resolveDynamicModel(e,t){switch(e){case"SELECT":return he;case"TEXTAREA":return de;default:switch(t){case"checkbox":return fe;case"radio":return me;default:return de}}}function callModelHook(e,t,n,s,o){const r=resolveDynamicModel(e.tagName,n.props&&n.props.type);const i=r[o];i&&i(e,t,n,s)}function initVModelForSSR(){de.getSSRProps=({value:e})=>({value:e});me.getSSRProps=({value:e},t)=>{if(t.props&&I(t.props.value,e))return{checked:true}};fe.getSSRProps=({value:e},t)=>{if(N(e)){if(t.props&&F(e,t.props.value)>-1)return{checked:true}}else if(j(e)){if(t.props&&e.has(t.props.value))return{checked:true}}else if(e)return{checked:true}};ve.getSSRProps=(e,t)=>{if("string"!==typeof t.type)return;const n=resolveDynamicModel(t.type.toUpperCase(),t.props&&t.props.type);return n.getSSRProps?n.getSSRProps(e,t):void 0}}const ge=["ctrl","shift","alt","meta"];const _e={stop:e=>e.stopPropagation(),prevent:e=>e.preventDefault(),self:e=>e.target!==e.currentTarget,ctrl:e=>!e.ctrlKey,shift:e=>!e.shiftKey,alt:e=>!e.altKey,meta:e=>!e.metaKey,left:e=>"button"in e&&0!==e.button,middle:e=>"button"in e&&1!==e.button,right:e=>"button"in e&&2!==e.button,exact:(e,t)=>ge.some((n=>e[`${n}Key`]&&!t.includes(n)))};const withModifiers=(e,t)=>(n,...s)=>{for(let e=0;e<t.length;e++){const s=_e[t[e]];if(s&&s(n,t))return}return e(n,...s)};const Ce={esc:"escape",space:" ",up:"arrow-up",left:"arrow-left",right:"arrow-right",down:"arrow-down",delete:"backspace"};const withKeys=(e,t)=>n=>{if(!("key"in n))return;const s=T(n.key);return t.some((e=>e===s||Ce[e]===s))?e(n):void 0};const ye={beforeMount(e,{value:t},{transition:n}){e._vod="none"===e.style.display?"":e.style.display;n&&t?n.beforeEnter(e):setDisplay(e,t)},mounted(e,{value:t},{transition:n}){n&&t&&n.enter(e)},updated(e,{value:t,oldValue:n},{transition:s}){if(!t!==!n)if(s)if(t){s.beforeEnter(e);setDisplay(e,true);s.enter(e)}else s.leave(e,(()=>{setDisplay(e,false)}));else setDisplay(e,t)},beforeUnmount(e,{value:t}){setDisplay(e,t)}};function setDisplay(e,t){e.style.display=t?e._vod:"none"}function initVShowForSSR(){ye.getSSRProps=({value:e})=>{if(!e)return{style:{display:"none"}}}}const be=L({patchProp:patchProp},G);let Ee;let Se=false;function ensureRenderer(){return Ee||(Ee=y(be))}function ensureHydrationRenderer(){Ee=Se?Ee:b(be);Se=true;return Ee}const render=(...e)=>{ensureRenderer().render(...e)};const hydrate=(...e)=>{ensureHydrationRenderer().hydrate(...e)};const createApp=(...e)=>{const t=ensureRenderer().createApp(...e);if("production"!==process.env.NODE_ENV){injectNativeTagCheck(t);injectCompilerOptionsCheck(t)}const{mount:n}=t;t.mount=e=>{const s=normalizeContainer(e);if(!s)return;const o=t._component;A(o)||o.render||o.template||(o.template=s.innerHTML);s.innerHTML="";const r=n(s,false,s instanceof SVGElement);if(s instanceof Element){s.removeAttribute("v-cloak");s.setAttribute("data-v-app","")}return r};return t};const createSSRApp=(...e)=>{const t=ensureHydrationRenderer().createApp(...e);if("production"!==process.env.NODE_ENV){injectNativeTagCheck(t);injectCompilerOptionsCheck(t)}const{mount:n}=t;t.mount=e=>{const t=normalizeContainer(e);if(t)return n(t,true,t instanceof SVGElement)};return t};function injectNativeTagCheck(e){Object.defineProperty(e.config,"isNativeTag",{value:e=>H(e)||B(e),writable:false})}function injectCompilerOptionsCheck(t){if(E()){const n=t.config.isCustomElement;Object.defineProperty(t.config,"isCustomElement",{get(){return n},set(){e("The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead.")}});const s=t.config.compilerOptions;const o='The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom';Object.defineProperty(t.config,"compilerOptions",{get(){e(o);return s},set(){e(o)}})}}function normalizeContainer(t){if(S(t)){const n=document.querySelector(t);"production"===process.env.NODE_ENV||n||e(`Failed to mount app: mount target selector "${t}" returned null.`);return n}"production"!==process.env.NODE_ENV&&window.ShadowRoot&&t instanceof window.ShadowRoot&&"closed"===t.mode&&e('mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs');return t}let Ne=false;const initDirectivesForSSR=()=>{if(!Ne){Ne=true;initVModelForSSR();initVShowForSSR()}};export{Transition,pe as TransitionGroup,VueElement,createApp,createSSRApp,defineCustomElement,defineSSRCustomElement,hydrate,initDirectivesForSSR,render,useCssModule,useCssVars,fe as vModelCheckbox,ve as vModelDynamic,me as vModelRadio,he as vModelSelect,de as vModelText,ye as vShow,withKeys,withModifiers};

